using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniController.Models;
using MiniController.Helpers;

namespace MiniController.Generators;

public static class SourceCodeGenerator
{
    public static void GenerateEndpointRegistration(SourceProductionContext context, EndpointGroupClass endpointGroup)
    {
        ValidateEndpoints(context, endpointGroup);

        var methodCount = endpointGroup.EndpointMethods.Count;
        var estimatedCapacity =
            500 +
            (methodCount * 200) +
            (endpointGroup.RoutePrefix?.Length ?? 0) * methodCount +
            100;

        var source = new StringBuilder(estimatedCapacity);

        source.AppendLine("// <auto-generated>");
        source.AppendLine("// 由EndpointGenerator自动生成，请勿修改");
        source.AppendLine("// </auto-generated>");
        source.AppendLine();
        source.AppendLine("using Microsoft.AspNetCore.Builder;");
        source.AppendLine("using Microsoft.AspNetCore.Http;");
        source.AppendLine("using Microsoft.AspNetCore.Mvc;");

        // 如果不是静态类，需要添加DI相关的命名空间
        if (!endpointGroup.IsStatic)
        {
            source.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            source.AppendLine("using System.Threading.Tasks;");
        }

        source.AppendLine();
        source.AppendLine($"namespace {endpointGroup.Namespace}");
        source.AppendLine("{");
        source.AppendLine($"    public static class {endpointGroup.ClassName}Extensions");
        source.AppendLine("    {");
        source.AppendLine($"        public static IEndpointRouteBuilder Map{endpointGroup.ClassName}(this IEndpointRouteBuilder builder)");
        source.AppendLine("        {");

        // 检查控制器路由是否包含 [action] 占位符
        var hasActionPlaceholder = !string.IsNullOrEmpty(endpointGroup.RoutePrefix) &&
                                  endpointGroup.RoutePrefix!.Contains("[action]");

        if (hasActionPlaceholder)
        {
            // 对于包含 [action] 的路由，直接注册每个方法到 builder，不使用 MapGroup
            GenerateDirectMethodRegistrations(source, endpointGroup);
        }
        else
        {
            // 对于不包含 [action] 的路由，使用传统的 MapGroup 方式
            GenerateGroupMethodRegistrations(source, endpointGroup);
        }

        source.AppendLine();
        source.AppendLine("            return builder;");
        source.AppendLine("        }");
        source.AppendLine("    }");
        source.AppendLine("}");

        context.AddSource($"{endpointGroup.ClassName}Extensions.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// 生成直接方法注册（用于包含 [action] 的路由）
    /// </summary>
    private static void GenerateDirectMethodRegistrations(StringBuilder source, EndpointGroupClass endpointGroup)
    {
        foreach (var method in endpointGroup.EndpointMethods)
        {
            // 解析控制器路由中的 [action] 占位符
            var resolvedRoute = RouteTemplateResolver.ResolveActionTemplate(
                endpointGroup.RoutePrefix!,
                method.Name,
                method.HttpMethod);

            // 如果方法有额外的路由模板，则追加
            if (!string.IsNullOrEmpty(method.RouteTemplate))
            {
                // 对于包含[action]的路由，方法的RouteTemplate应该直接追加，不需要重复action部分
                if (resolvedRoute.EndsWith("/") || method.RouteTemplate.StartsWith("/"))
                {
                    resolvedRoute = resolvedRoute.TrimEnd('/') + "/" + method.RouteTemplate.TrimStart('/');
                }
                else
                {
                    resolvedRoute = resolvedRoute + "/" + method.RouteTemplate;
                }
            }

            // 生成端点注册代码，支持静态和实例方法
            if (endpointGroup.IsStatic || method.IsStatic)
            {
                source.Append($"            builder.Map{method.HttpMethod}(\"{resolvedRoute}\", {endpointGroup.ClassName}.{method.Name})");
            }
            else
            {
                source.Append($"            builder.Map{method.HttpMethod}(\"{resolvedRoute}\", ");
                GenerateInstanceMethodDelegate(source, method, endpointGroup.ClassName);
                source.Append($")");
            }

            // 添加授权
            if (method.Authorize != null)
            {
                var authorizeCall = BuildAuthorizeCall(method.Authorize);
                if (!string.IsNullOrEmpty(authorizeCall))
                {
                    source.Append(authorizeCall);
                }
            }
            else if (endpointGroup.Authorize != null)
            {
                var authorizeCall = BuildAuthorizeCall(endpointGroup.Authorize);
                if (!string.IsNullOrEmpty(authorizeCall))
                {
                    source.Append(authorizeCall);
                }
            }

            // 添加API Explorer设置
            if (method.ApiExplorerSettings != null)
            {
                var apiExplorerCall = BuildApiExplorerSettingsCall(method.ApiExplorerSettings);
                if (!string.IsNullOrEmpty(apiExplorerCall))
                {
                    source.Append(apiExplorerCall);
                }
            }
            else
            {
                source.Append($".WithTags(\"{endpointGroup.ClassName}\").WithOpenApi()");
            }

            // 添加响应类型
            foreach (var responseType in method.ResponseTypes ?? Enumerable.Empty<ResponseTypeMetadata>())
            {
                AppendProducesCall(source, responseType);
            }

            // 添加过滤器
            if (!string.IsNullOrEmpty(method.FilterType))
            {
                source.Append($".AddEndpointFilter<{method.FilterType}>()");
            }
            else if (!string.IsNullOrEmpty(endpointGroup.FilterType))
            {
                source.Append($".AddEndpointFilter<{endpointGroup.FilterType}>()");
            }

            source.AppendLine(";");
        }
    }

    /// <summary>
    /// 生成组方法注册（用于不包含 [action] 的路由）
    /// </summary>
    private static void GenerateGroupMethodRegistrations(StringBuilder source, EndpointGroupClass endpointGroup)
    {
        source.AppendLine($"            var group = builder.MapGroup(\"{endpointGroup.RoutePrefix}\");");

        if (endpointGroup.Authorize != null)
        {
            var authorizeCall = BuildAuthorizeCall(endpointGroup.Authorize);
            source.AppendLine($"            group{authorizeCall};");
        }

        if (!string.IsNullOrEmpty(endpointGroup.FilterType))
        {
            source.AppendLine($"            group.AddEndpointFilter<{endpointGroup.FilterType}>();");
        }

        source.AppendLine();

        foreach (var method in endpointGroup.EndpointMethods)
        {
            BuildMethodRegistration(source, endpointGroup, method, endpointGroup.ClassName, endpointGroup.IsStatic);
        }
    }

    public static void GenerateMiniControllerRegistration(SourceProductionContext context, List<(string nameSpace, string className)> ClassInfoList)
    {
        var estimatedCapacity = 300 + (ClassInfoList.Count * 50);
        var Extension = new StringBuilder(estimatedCapacity);

        Extension.AppendLine("// <auto-generated>");
        Extension.AppendLine("// 由EndpointGenerator自动生成，请勿修改");
        Extension.AppendLine("// </auto-generated>");
        Extension.AppendLine();
        Extension.AppendLine("using Microsoft.AspNetCore.Builder;");
        Extension.AppendLine("using Microsoft.AspNetCore.Http;");

        var uniqueNamespaces = ClassInfoList.Select(c => c.nameSpace).Distinct();
        foreach (var ns in uniqueNamespaces)
        {
            Extension.AppendLine($"using {ns};");
        }

        Extension.AppendLine();
        Extension.AppendLine("namespace Microsoft.AspNetCore.Builder");
        Extension.AppendLine("{");
        Extension.AppendLine("    public static class MiniControllerExtensions");
        Extension.AppendLine("    {");
        Extension.AppendLine("        public static IEndpointRouteBuilder MapMiniController(this IEndpointRouteBuilder builder)");
        Extension.AppendLine("        {");

        foreach (var classInfo in ClassInfoList)
        {
            Extension.AppendLine($"            builder.Map{classInfo.className}();");
        }

        Extension.AppendLine("            return builder;");
        Extension.AppendLine("        }");
        Extension.AppendLine("    }");
        Extension.AppendLine("}");

        context.AddSource("MiniControllerExtensions.g.cs", SourceText.From(Extension.ToString(), Encoding.UTF8));
    }

    /// <summary>
    /// 生成依赖注入注册扩展方法
    /// </summary>
    public static void GenerateDependencyInjectionRegistration(SourceProductionContext context, List<EndpointGroupClass> endpointGroups)
    {
        var nonStaticGroups = endpointGroups.Where(g => !g.IsStatic).ToList();
        if (nonStaticGroups.Count == 0)
            return;

        var estimatedCapacity = 500 + (nonStaticGroups.Count * 100);
        var source = new StringBuilder(estimatedCapacity);

        source.AppendLine("// <auto-generated>");
        source.AppendLine("// 由EndpointGenerator自动生成，请勿修改");
        source.AppendLine("// </auto-generated>");
        source.AppendLine();
        source.AppendLine("using Microsoft.Extensions.DependencyInjection;");

        var uniqueNamespaces = nonStaticGroups.Select(g => g.Namespace).Distinct();
        foreach (var ns in uniqueNamespaces)
        {
            source.AppendLine($"using {ns};");
        }

        source.AppendLine();
        source.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
        source.AppendLine("{");
        source.AppendLine("    public static class MiniControllerServiceCollectionExtensions");
        source.AppendLine("    {");
        source.AppendLine("        /// <summary>");
        source.AppendLine("        /// 注册所有MiniController到依赖注入容器");
        source.AppendLine("        /// </summary>");
        source.AppendLine("        public static IServiceCollection AddMiniControllers(this IServiceCollection services)");
        source.AppendLine("        {");

        foreach (var group in nonStaticGroups)
        {
            // MiniController固定使用Transient生命周期
            source.AppendLine($"            services.AddTransient<{group.ClassName}>();");
        }

        source.AppendLine("            return services;");
        source.AppendLine("        }");
        source.AppendLine("    }");
        source.AppendLine("}");

        context.AddSource("MiniControllerServiceCollectionExtensions.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private static void BuildMethodRegistration(StringBuilder source, EndpointGroupClass endpointGroup, EndpointMethod method, string className, bool isStatic)
    {
        if (method == null || string.IsNullOrEmpty(method.Name))
        {
            return; // 跳过无效的方法
        }

        if (isStatic || method.IsStatic)
        {
            // 静态方法调用
            source.Append($"            group.Map{method.HttpMethod}(\"{method.RouteTemplate}\", {className}.{method.Name})");
        }
        else
        {
            // 实例方法调用 - 生成智能的参数绑定
            source.Append($"            group.Map{method.HttpMethod}(\"{method.RouteTemplate}\", ");
            GenerateInstanceMethodDelegate(source, method, className);
            source.Append(")");
        }

        if (method.Authorize != null)
        {
            var authorizeCall = BuildAuthorizeCall(method.Authorize);
            if (!string.IsNullOrEmpty(authorizeCall))
            {
                source.Append(authorizeCall);
            }
        }

        if (method.ApiExplorerSettings != null)
        {
            var apiExplorerCall = BuildApiExplorerSettingsCall(method.ApiExplorerSettings);
            if (!string.IsNullOrEmpty(apiExplorerCall))
            {
                source.Append(apiExplorerCall);
            }
        }
        else
        {
            source.Append($".WithTags(\"{endpointGroup.ClassName}\").WithOpenApi()");
        }

        // 添加响应类型
        foreach (var responseType in method.ResponseTypes ?? Enumerable.Empty<ResponseTypeMetadata>())
        {
            AppendProducesCall(source, responseType);
        }

        // 添加过滤器
        if (!string.IsNullOrEmpty(method.FilterType))
        {
            source.Append($".AddEndpointFilter<{method.FilterType}>()");
        }

        source.AppendLine(";");
    }

    /// <summary>
    /// 生成实例方法的委托调用
    /// </summary>
    private static void GenerateInstanceMethodDelegate(StringBuilder source, EndpointMethod method, string className)
    {
        var parameters = method.Parameters ?? new List<MethodParameterInfo>();
        
        // 如果没有参数，生成简单的调用
        if (parameters.Count == 0)
        {
            source.Append($"([FromServices] {className} controller) => ");
            source.Append($"controller.{method.Name}()");
            return;
        }

        // 生成参数列表
        source.Append("(");
        
        var parameterList = new List<string>();
        var callArguments = new List<string>();

        // 首先添加控制器参数
        parameterList.Add($"[FromServices] {className} controller");

        // 添加其他参数
        foreach (var param in parameters)
        {
            var paramDeclaration = GenerateParameterDeclaration(param);
            parameterList.Add(paramDeclaration);
            callArguments.Add(param.Name);
        }

        source.Append(string.Join(", ", parameterList));
        source.Append(") => ");

        // 检查返回类型是否需要await
        var needsAsync = method.ReturnType.Contains("Task") || method.ReturnType.Contains("ValueTask");
        
        if (needsAsync)
        {
            source.Append($"controller.{method.Name}(");
        }
        else
        {
            source.Append($"controller.{method.Name}(");
        }

        source.Append(string.Join(", ", callArguments));
        source.Append(")");
    }

    /// <summary>
    /// 生成参数声明
    /// </summary>
    private static string GenerateParameterDeclaration(MethodParameterInfo param)
    {
        var attributes = new List<string>();

        if (param.IsFromServices)
            attributes.Add("[FromServices]");
        else if (param.IsFromRoute)
            attributes.Add("[FromRoute]");
        else if (param.IsFromQuery)
            attributes.Add("[FromQuery]");
        else if (param.IsFromBody)
            attributes.Add("[FromBody]");
        else if (param.IsFromHeader)
            attributes.Add("[FromHeader]");
        else if (param.IsFromForm)
            attributes.Add("[FromForm]");

        var attributeString = attributes.Count > 0 ? string.Join(" ", attributes) + " " : "";
        return $"{attributeString}{param.Type} {param.Name}";
    }

    private static void AppendProducesCall(StringBuilder source, ResponseTypeMetadata responseType)
    {
        if (responseType == null) return;

        if (!string.IsNullOrEmpty(responseType.TypeName))
        {
            source.Append($".Produces<{responseType.TypeName}>({responseType.StatusCode}");
            if (!string.IsNullOrEmpty(responseType.ContentType))
            {
                source.Append($", \"{responseType.ContentType}\"");
            }
            source.Append(')');
        }
        else
        {
            source.Append($".Produces({responseType.StatusCode}");
            if (!string.IsNullOrEmpty(responseType.ContentType))
            {
                source.Append($", \"{responseType.ContentType}\"");
            }
            source.Append(')');
        }
    }

    private static string BuildAuthorizeCall(AuthorizeMetadata metadata)
    {
        if (metadata?.AllowAnonymous == true)
        {
            return ".AllowAnonymous()";
        }

        if (metadata == null)
            return string.Empty;

        var arguments = new List<string>(3);

        if (!string.IsNullOrEmpty(metadata.Policy))
            arguments.Add($"\"{metadata.Policy}\"");

        if (!string.IsNullOrEmpty(metadata.Roles))
            arguments.Add($"Roles: \"{metadata.Roles}\"");

        if (!string.IsNullOrEmpty(metadata.AuthenticationSchemes))
            arguments.Add($"AuthenticationSchemes: \"{metadata.AuthenticationSchemes}\"");

        if (arguments.Count == 0)
            return ".RequireAuthorization()";

        return $".RequireAuthorization({string.Join(", ", arguments)})";
    }

    private static string BuildApiExplorerSettingsCall(ApiExplorerSettingsMetadata settings)
    {
        if (settings == null) return string.Empty;

        var result = new StringBuilder(64);

        if (settings.IgnoreApi == true)
        {
            result.Append(".ExcludeFromDescription()");
        }
        else
        {
            result.Append(".WithOpenApi()");
        }

        if (!string.IsNullOrEmpty(settings.GroupName))
        {
            result.Append($".WithTags(\"{settings.GroupName}\")");
        }

        return result.ToString();
    }

    private static void ValidateEndpoints(SourceProductionContext context, EndpointGroupClass endpointGroup)
    {
        if (endpointGroup?.EndpointMethods == null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                CreateDiagnosticDescriptor("MC002", "无效的端点组", "端点组或其方法列表为空", DiagnosticSeverity.Error),
                Location.None));
            return;
        }

        var routeMap = new Dictionary<string, List<string>>(endpointGroup.EndpointMethods.Count);

        foreach (var method in endpointGroup.EndpointMethods)
        {
            if (method == null) continue;

            // 构建完整的路由用于冲突检测
            string fullRoute = BuildFullRouteForValidation(endpointGroup, method);
            var key = $"{method.HttpMethod}:{fullRoute}";
            
            if (!routeMap.TryGetValue(key, out var methods))
            {
                routeMap[key] = new List<string> { method.Name };
            }
            else
            {
                methods.Add(method.Name);
                context.ReportDiagnostic(Diagnostic.Create(
                    CreateDiagnosticDescriptor("MC001", "路由冲突",
                        $"控制器 {endpointGroup.ClassName} 中的方法 {string.Join(", ", methods)} 具有相同的路由 {key}",
                        DiagnosticSeverity.Warning),
                    Location.None));
            }
        }
    }

    /// <summary>
    /// 构建用于验证的完整路由
    /// </summary>
    private static string BuildFullRouteForValidation(EndpointGroupClass endpointGroup, EndpointMethod method)
    {
        var routePrefix = endpointGroup.RoutePrefix ?? "";
        var methodRoute = method.RouteTemplate ?? "";

        // 如果控制器路由包含[action]占位符，需要解析
        if (routePrefix.Contains("[action]"))
        {
            return RouteTemplateResolver.ResolveActionTemplate(
                routePrefix, 
                method.Name, 
                method.HttpMethod);
        }

        // 对于普通路由，组合前缀和方法路由
        if (string.IsNullOrEmpty(methodRoute))
        {
            return routePrefix;
        }

        if (routePrefix.EndsWith("/") || methodRoute.StartsWith("/"))
        {
            return routePrefix.TrimEnd('/') + "/" + methodRoute.TrimStart('/');
        }
        else
        {
            return routePrefix + "/" + methodRoute;
        }
    }

    private static DiagnosticDescriptor CreateDiagnosticDescriptor(string id, string title, string messageFormat, DiagnosticSeverity severity)
    {
        return new DiagnosticDescriptor(
            id,
            title,
            messageFormat,
            "MiniController",
            severity,
            isEnabledByDefault: true,
            description: $"MiniController 源码生成器诊断：{title}"
        );
    }
}